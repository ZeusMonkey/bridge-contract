// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import "../interfaces/IBridgeHandler.sol";
import "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";

/**
    @title Handles ERC20 deposits and deposit executions.
    @author Ryuhei Matsuda
    @notice This contract is intended to be used with the Bridge contract.
 */
contract BridgeHandler is IBridgeHandler {
    struct DepositRecord {
        uint8 destinationChainID;
        address destinationRecipientAddress;
        address depositer;
        uint256 amount;
    }

    address public token;
    address public bridgeAddress;

    modifier onlyBridge() {
        require(msg.sender == bridgeAddress, "sender must be bridge contract");
        _;
    }
    // destId => depositNonce => Deposit Record
    mapping(uint8 => mapping(uint64 => DepositRecord)) public depositRecords;

    /**
        @param _bridgeAddress Contract address of previously deployed Bridge.
        @param _tokenAddress Contract address of token.
     */
    constructor(address _bridgeAddress, address _tokenAddress) {
        bridgeAddress = _bridgeAddress;
        token = _tokenAddress;
    }

    /**
        @param _depositNonce This ID will have been generated by the Bridge contract.
        @param _destId ID of chain deposit will be bridged to.
    */
    function getDepositRecord(uint64 _depositNonce, uint8 _destId)
        external
        view
        returns (DepositRecord memory)
    {
        return depositRecords[_destId][_depositNonce];
    }

    /**
        @notice A deposit is initiatied by making a deposit in the Bridge contract.
        @param _destinationChainID Chain ID of chain tokens are expected to be bridged to.
        @param _depositNonce This value is generated as an ID by the Bridge contract.
        @param _depositer Address of account making the deposit in the Bridge contract.
        @param _amount Token amount to deposit.
        @param _recipient Address to receive.
     */
    function deposit(
        uint8 _destinationChainID,
        uint64 _depositNonce,
        address _depositer,
        uint256 _amount,
        address _recipient
    ) external override onlyBridge {
        burnERC20(_depositer, _amount);

        depositRecords[_destinationChainID][_depositNonce] = DepositRecord(
            _destinationChainID,
            _recipient,
            _depositer,
            _amount
        );
    }

    /**
        @param _amount Token amount to deposit.
        @param _recipient Address to receive.
     */
    function executeProposal(uint256 _amount, address _recipient)
        external
        override
        onlyBridge
    {
        mintERC20(_recipient, _amount);
    }

    /**
        @notice Used to create new ERC20s.
        @param _recipient Address to mint token to.
        @param _amount Amount of token to mint.
     */
    function mintERC20(address _recipient, uint256 _amount) internal {
        ERC20PresetMinterPauser erc20 = ERC20PresetMinterPauser(token);
        erc20.mint(_recipient, _amount);
    }

    /**
        @notice Used to burn ERC20s.
        @param _owner Current owner of tokens.
        @param _amount Amount of tokens to burn.
     */
    function burnERC20(address _owner, uint256 _amount) internal {
        ERC20Burnable erc20 = ERC20Burnable(token);
        erc20.burnFrom(_owner, _amount);
    }
}
